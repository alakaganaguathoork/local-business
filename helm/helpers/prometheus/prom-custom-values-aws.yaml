server:
  extraFlags:
    - web.enable-lifecycle
    - web.external-url=/prometheus
    - web.route-prefix=/

  # ingress:
    # enabled: true
    # ingressClassName: alb
    # annotations:
      # kubernetes.io/ingress.class: alb
      # alb.ingress.kubernetes.io/load-balancer-name: monitoring-alb
      # alb.ingress.kubernetes.io/group.name: shared-alb      # use group only if you want to override it or use a non-default
      # alb.ingress.kubernetes.io/group.order: "10"       # (rule priority among group)
      # # alb.ingress.kubernetes.io/scheme: internet-facing
      # alb.ingress.kubernetes.io/target-type: ip
      # alb.ingress.kubernetes.io/listen-ports: '[{"HTTP":80}]'
      # alb.ingress.kubernetes.io/healthcheck-path: /-/healthy

        # For HTTPS
      # alb.ingress.kubernetes.io/listen-ports: '[{"HTTPS":443}]'
      # alb.ingress.kubernetes.io/certificate-arn: arn:aws:acm:REGION:ACCT:certificate/UUID
      # alb.ingress.kubernetes.io/ssl-redirect: "443"
    # hosts: []
    # path: /
    # pathType: Prefix
    # extraRules: []
    # path: /
    # extraRules:
      # - http:
          # paths:
            # - path: /
              # pathType: Prefix
              # backend:
                # service:
                  # name: prometheus-server
                  # port:
                    # number: 80 
    
    # https://docs.aws.amazon.com/eks/latest/userguide/deploy-prometheus.html + a custom storageClass gp3 was needed (via terraform)
  persistentVolume:
    storageClass: "gp3"

alertmanager:
  persistence:
    storageClass: "gp3"

    # EKS: keep persistence on gp3 (or your default SC)
  # persistentVolume:
    # enabled: true
    # size: 1Gi
    # storageClass: gp2               # EKS
  
    # Make /data writable for Prometheus (non-root UID 65534)
  # podSecurityContext:
    # # runAsUser: 65534
    # runAsGroup: 65534
    # fsGroup: 65534
    # fsGroupChangePolicy: OnRootMismatch
 
  # securityContext:
    # runAsNonRoot: true
    # allowPrivilegeEscalation: false

    # Some drivers ignore fsGroup; ensure ownership once at startup
  # extraInitContainers:
    # - name: fix-perms
      # image: busybox:1.36
      # command: ["sh","-c","chown -R 65534:65534 /data || true; chmod -R g+rwX /data || true"]
      # securityContext:
        # runAsUser: 0
        # runAsGroup: 0
      # volumeMounts:
        # - name: storage-volume
          # mountPath: /data
  
serverFiles:
  alerting_rules.yml:
    groups:
      - name: node_exporter_alert
        rules:
          - record: job_instance_mode:node_cpu_seconds:avg_rate5m
            expr: avg by (job, instance, mode) (rate(node_cpu_seconds_total[5m]))
      
          - alert: InstanceDown
            expr: up == 0
            for: 5m
            labels:
              severity: instance_down
            annotations:
              description: '{{ $labels.instance }} of job {{ $labels.job }} has been down for more than 5 minutes.'
              summary: 'Instance {{ $labels.instance }} is down'

extraScrapeConfigs: |
  - job_name: 'local-business-pods'
    kubernetes_sd_configs:
      - role: pod
        namespaces:
          names: ["app"]

    relabel_configs:
      # keep only pods with label app.kubernetes.io/name=local-business
      - action: keep
        source_labels: [__meta_kubernetes_pod_label_app_kubernetes_io_name]
        regex: local-business
      # keep containers that expose a port named "metrics"
      # - action: keep
        # source_labels: [__meta_kubernetes_pod_container_port_name]
        # regex: metrics
      # set address to <podIP>:<containerPort> (covers IPv4/IPv6)
      - action: replace
        source_labels: [__meta_kubernetes_pod_ip, __meta_kubernetes_pod_container_port_number]
        target_label: __address__
        regex: (.+);(.+)
        replacement: $1:$2
    metrics_path: /metrics
    scheme: http